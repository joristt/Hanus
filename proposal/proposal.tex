\documentclass[12pt,a4paper]{article}

% Tables
\usepackage{multicol}
\usepackage{multirow}

% Colors
\usepackage{xcolor, color, colortbl}
\colorlet{gray}{gray!70}
\colorlet{green}{green!50}

% Links
\usepackage{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour}

\title{\textbf{Project Proposal \\ \small{Concepts of Program Design}}}
\author{\small{Joris ten Tusscher, Joris Burgers, Ivo-Gabe de Wolff, Cas van der Rest, Orestis Melkonian}}
\date{}

\begin{document}
\maketitle

\section{Background}
\begin{itemize}
	\item{Reversible Computation}
	\item{Janus}
	\item{other languages}
	\item{a bit of theory}
\end{itemize}

\section{Problem}
	\subsection{Experiment}
	
	\subsection{Extensions}
	\begin{itemize}
		\item{Data structures (trees/sets/maps/ADTs)}
		\item{Prelude}
		\item{Syntactic sugar}
	\end{itemize}
	
	\subsection{Applications}
	Although, logically, certain programs cannot be implemented in a reversible language, some definitely can be. A few applications that can be implemented in a time-reversible language will be implemented in Janus as part of this project:
	\begin{itemize}
		\item
			a pathfinding algorithm such as BFS or DFS, where you can also automatically backtrack;
	        \item
	        		a simple encoding or symmetric encryption algorithm, which can also be decoded or decrypted using the inverse function;
	        	\item
			the Hamming(7,4) function, which takes 4 bits as input and returns the four input bits plus three parity bits that can be used to correct an incorrect bit\cite{hamming}. The inverse if Hamming(7,4) can, given the 7 bits, return the 4 original input bits, assuming that at most 1 of the 7 bits is incorrect.
        		\item
			Optional: a debugger in which one can go back in time, i.e. reverse already executed statements. This will likely be much more difficult to implement than the other application mentioned above, so it will only be implemented if there is sufficient time.
	\end{itemize}
	
	\subsection{Benchmarking}
	\begin{itemize}
		\item{Janus vs rFun}
		\item{LOC metrics}
	\end{itemize}
	
	\subsection{Formal verification}
	\begin{itemize}
		\item{Reversibility}
		\item{Verifying pre/post-conditions}
		\item{r-Turing Completeness}
	\end{itemize}

\section{Methodology}
\begin{itemize}
	\item{Template Haskell \footnote{\url{https://wiki.haskell.org/Template_Haskell}}}
	\begin{itemize}
		\item{Embedding Janus}
		\item{Compile-time guarantees}
		\begin{itemize}
			\item{Type-checking}
			\item{Variable usage}
		\end{itemize}
		
	\end{itemize}
	
	\item{GHC Profiling}
	\begin{itemize}
		\item{Criterion package \footnote{\url{http://hackage.haskell.org/package/criterion})}}
	\end{itemize}
	
	\item{Liquid Haskell \footnote{\url{https://ucsd-progsys.github.io/liquidhaskell-blog/})}}
	\begin{itemize}
		\item{Theorem proving}
	\end{itemize}
\end{itemize}

\section{Planning}

\setlength{\tabcolsep}{20pt}
\renewcommand{\arraystretch}{1.6}
\begin{center}
\begin{tabular}{cl}
\multirow{2}{*}{\textsc{week 1}} &
	\textbf{Task 1:} Orestis,... \\ {} &
	\textbf{Task 2:} Cas,... \\ \hline
\multirow{2}{*}{\textsc{week 2}} &
	\textbf{Task 3:} Joris1, Joris2,... \\ {} &
\textbf{Task 4:} Ivo,... \\ \hline
\multirow{2}{*}{\textsc{week 3}} &
	\textbf{Task 1:} Orestis,... \\ {} &
	\textbf{Task 2:} Cas,... \\
\rowcolor{green} \multicolumn{2}{c}{\textsc{Progress Report}} \\
\multirow{2}{*}{\textsc{week 4}} &
	\textbf{Task 3:} Joris1, Joris2,... \\ {} &
	\textbf{Task 4:} Ivo,... \\ \hline
\multirow{2}{*}{\textsc{week 5}} &
	\textbf{Task 1:} Orestis,... \\ {} &
	\textbf{Task 2:} Cas,... \\ \hline
\multirow{2}{*}{\textsc{week 6}} &
	\textbf{Task 3:} Joris1, Joris2,... \\ {} &
	\textbf{Task 4:} Ivo,... \\
\rowcolor{green} \multicolumn{2}{c}{\textsc{Project Submission}}
\end{tabular}
\end{center}

\newpage
\begin{thebibliography}{99}
\bibitem{hamming}
Hamming, R. W. (1950). Error detecting and error correcting codes. Bell Labs Technical Journal, 29(2), 147-160.
\end{thebibliography}

\end{document}
