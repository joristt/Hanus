\documentclass[12pt,a4paper]{article}

% Links
\usepackage{hyperref}
\usepackage{xcolor}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour}

\title{\textbf{Project Proposal \\ \small{Concepts of Program Design}}}
\author{\small{Joris ten Tusscher, Joris Burgers, Ivo-Gabe de Wolff, Cas van der Rest, Orestis Melkonian}}
\date{}

\begin{document}
\maketitle

\section{Background}
\begin{itemize}
	\item{Reversible Computation}
	\item{other languages}
	\item{a bit of theory}
\end{itemize}

\section{Problem}
	\subsection{Experiment}
	
	\subsection{Janus}
	We want to implement the reversible programming language Janus as an DSL in Haskell. For the syntax and semantics the definitions as given by Lutz en Derby \cite{r:lutz-derby1982} will be used. There will however be a few changes. There will be no input and output in the DSL. Therefore, the READ and WRITE statements will not be valid statements. Beside this limitation, the DSL will allow arbitrary Haskell expressions to the right-hand side of Janus statements, enabling programmers to reuse Haskell code. This freedom of accepting Haskell code will not limit the reversibility of the DSL. , since the semantics for Janus require statements to be reversible, but not right-hand expression. For instance, the statement $x += f$ where $f$ is any valid Haskell expression. As long as $f$ does not depend on $x$, the statement can be inverted by the statement $x -= f$.
	
	\subsection{Extensions}
	\begin{itemize}
		\item{Data structures (trees/sets/maps/ADTs)}
		\item{Prelude}
		\item{Syntactic sugar}
	\end{itemize}
	
	\subsection{Applications}
	\begin{itemize}
		\item{Path finding algorithms}
        \item{Encoding-Decoding}
        \item{Low-level bit manipulation (hamming error correction)}
        \item{[Optional] Reversible Debugger}
	\end{itemize}
	
	\subsection{Benchmarking}
	\begin{itemize}
		\item{Janus vs rFun}
		\item{LOC metrics}
	\end{itemize}
	
	\subsection{Formal verification}
	\begin{itemize}
		\item{Reversibility}
		\item{Verifying pre/post-conditions}
		\item{r-Turing Completeness}
	\end{itemize}

\section{Methodology}
\begin{itemize}
	\item{Template Haskell \footnote{\url{https://wiki.haskell.org/Template_Haskell}}}
	\begin{itemize}
		\item{Embedding Janus}
		\item{Compile-time guarantees}
		\begin{itemize}
			\item{Type-checking}
			\item{Variable usage}
		\end{itemize}
		
	\end{itemize}
	
	\item{GHC Profiling}
	\begin{itemize}
		\item{Criterion package \footnote{\url{http://hackage.haskell.org/package/criterion})}}
	\end{itemize}
	
	\item{Liquid Haskell \footnote{\url{https://ucsd-progsys.github.io/liquidhaskell-blog/})}}
	\begin{itemize}
		\item{Theorem proving}
	\end{itemize}
\end{itemize}

\section{Planning}
\begin{itemize}
	\item{Milestones}
	\item{Division of labour}
\end{itemize}

\end{document}
