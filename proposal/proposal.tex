\documentclass[12pt,a4paper]{article}

% Tables
\usepackage{multicol}
\usepackage{multirow}
\usepackage{csquotes}

% Colors
\usepackage{xcolor, color, colortbl}
\colorlet{gray}{gray!70}
\colorlet{green}{green!50}

% Links
\usepackage{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour}

\title{\textbf{Project Proposal \\ \small{Concepts of Program Design}}}
\author{\small{Joris ten Tusscher, Joris Burgers, Ivo-Gabe de Wolff, Cas van der Rest, Orestis Melkonian}}
\date{}

% Macros
\newcommand{\site}[1]{\footnote{\url{#1}}}

\begin{document}
\maketitle

\section{Background}
\begin{itemize}
	\item{Reversible Computation}
	\item{other languages}
	\item{a bit of theory}
\end{itemize}

\section{Problem}
	\subsection{Experiment}
	The main research question that we want to be able to answer when we have conducted our experiment is:
	
	\begin{displayquote}
	\textit{can we improve the usability of Janus by implementing it as a DSL embedded in haskell?}
	\end{displayquote}
	
	\noindent In order to be able to answer this question, we will attempt to improve Janus in multiple ways:
	\begin{itemize}
		\item making it possible to put most Haskell expressions on the right hand side of a Janus statement. See section \ref{subsec:template-haskell} for an explanation on why not every possible Haskell expression is allowed.
		\item Adding extra operators to Janus.
		\item Verification of our Janus implementation using Liquid Haskell\ref{liquidhaskell}.
		\item Extending Janus with arbitrary types, meaning that a user should be able to define a type, define operators that work on that type, define what the operators do and lastly, define what the inverse of every operator is.
	\end{itemize}
	Several Janus applications will be implemented and tested using our own Janus DSL and existing solutions, and the performances of the implementations will be measured and compared, for example by measuring execution time of the programs, memory usage and the number of lines of code every Janus implementation needs for the different applications that we will implement. The performance will also be measured in ways that are not trivially quantifiable, for example by looking at the expressiveness of the different Janus implementations.
	
	\subsection{Janus}
	We want to implement the reversible programming language Janus as an DSL in Haskell. The syntax and semantics given by Lutz en Derby \cite{r:lutz-derby1982} will be used. There will however be a few changes. There will be no input and output in the DSL. Therefore, the READ and WRITE statements will not be valid statements. Besides this limitation, the DSL will allow arbitrary Haskell expressions to the right-hand side of Janus statements, enabling programmers to reuse Haskell code. This freedom of accepting Haskell code will not limit the reversibility of the DSL, since the semantics for Janus require statements to be reversible, but not right-hand expressions. For instance, the statement $x += f$ where $f$ is any valid Haskell expression. As long as $f$ does not depend on $x$, the statement can be inverted by the statement $x -= f$.
	
	\subsection{Extensions}
	\begin{itemize}
		\item{Data structures (trees/sets/maps/ADTs)}
		\item{Prelude}
		\item{Syntactic sugar}
	\end{itemize}
	
	\subsection{Applications}
	\begin{itemize}
		\item{Path finding algorithms}
        \item{Encoding-Decoding}
        \item{Low-level bit manipulation (hamming error correction)}
        \item{[Optional] Reversible Debugger}
	\end{itemize}
	
	\subsection{Comparison with Existing Implementations}
    \subsubsection{Benchmarking}
    We intend to compare the performance of our embedded DSL to existing implementations of the Janus language. We will do so by implementing the same algorithms in both our DSL and standard Janus, and comparing the time it takes the different implementations to compile and run the programs, as well as memory usage.
    \subsubsection{Other Metrics}
    Since our main goal is to improve the usability of Janus, it is hard to come up with metrics that provide a useful insight in the quality of our result. Certainly, performance alone will not be enough to capture the differences between the embedding and existing implementations. In order to attempt to measure the quality of our result beyond raw performance, we will compare our results with existing implementations with respect to the following aspects as well. 
	\begin{itemize}
		\item{LOC when implementing a certain algorithm}
		\item{The amount of language constructs and abstractions at a programmer's disposal when solving problems}
        \item{The ability to use patterns/constructs that are generally considered as idiomatic or elegant within the programming community}
	\end{itemize}
Admittedly, most of the above comes down to opinion. We think that it is useful to think about these aspects when considering our results nonetheless. 
	
\subsection{Formal verification}
To our knowledge, there is no formally verified interpreter for Janus. The most interesting propositions to prove about an implementation of Janus are the following:
\begin{itemize}
	\item r-Turing completeness
	\item Automated verification of conditional and loop assertions
	\item Reversibility of Janus programs
\end{itemize}
We aim on formally verifying the reversibility of Janus programs, because it appears to be the most feasible option, while being as meaningful as the rest.

\section{Methodology}
\subsection{Template Haskell}
\label{subsec:template-haskell}
In order to embed Janus as a DSL in Haskell, we are going to use the \textit{TemplateHaskell}(TH) and \textit{QuasiQuotation} GHC extensions, which extend Haskell with compile-time meta-programming capabilities. This will allow us to perform static checking (i.e. syntactic and semantic checking), code generation and embedding Haskell expressions in Janus at compile-time.

Our main focus will be on static checking, as we are not planning to generate low-level efficient code for running our Janus programs. Nonetheless, we plan on using compile-time code generation to automatically derive the inverse of each declared Janus function and we expect this to give significant performance gains, since at the evaluation of an \textbf{uncall} statement, we will bypass the elaborate procedure of reversing the given function, whose computation time depends on its size.

On the static checking side of things, TH will allow us to perform the following at compile-time:
\begin{itemize}
	\item{Parsing}
	\item{Checking programs are well-typed}
	\item{Proper variable usage}
	\item{Embedding of Haskell expressions}
\end{itemize}

Specifically, Janus programs will be written as \textit{quasi-quote} strings inside a Haskell source file, which will eventually transfer control to a \textit{quasi quoter}, that will parse and statically check desired properties of the given program, as well as compile the domain-specific syntax to Haskell code.

For instance, Janus statements of the form \textbf{id} $\langle\textsc{reversibleOp}\rangle$ \textbf{expr} require that the identifier on the left-hand side does not occur in the expression on the right-hand side. This is easily achieved in TH via the process of \textit{reification}, which allows us to query compile-time information (e.g. a variable's type and identifier) while running our meta-programs.

In addition to compile-time guarantees, the embedded Janus language will also inherit powerful features, already existent in Haskell (e.g. modularity via Haskell's modules).
	
\subsection{Benchmarking}
	\begin{itemize}
		\item{GHC Profiling}
		\item{Criterion package\site{http://hackage.haskell.org/package/criterion}}
	\end{itemize}

\subsection{Formal Verification}
In order to verify the reversibility of Janus programs, we will use \textit{LiquidHaskell}, which extends Haskell with refinement types (i.e. types accompanied by logical predicates that enforce certain properties). \textit{LiquidHaskell} will enable us to write Haskell functions, which will act as equation proofs of the reversibility of all possible Janus programs.

Mechanically checking the above statement can be achieved by performing structural induction on the syntax of our DSL. Technically, this proof will correspond to a Haskell function, which will perform recursion on the data types of our AST, via the process of \textit{refinement reflection} (i.e. reflecting the code of a function in its output type).

\subsection{Risk and contingency plans}
There are a number of risks to consider when creating a DSL, which are specified below with their respective contingency plans.
\begin{itemize}
\item \textbf{Arbitrary types} The plan is to implement arbitrary types in the DSL. It is expected that implementing arbitrary types will take a long time and therefore, the risk exists that the implementation can not be completed in the given timespan. The contingency plan, if this goal takes too much time, is to reduce arbitrary types to some special types.
\item \textbf{Full verification} The goal is to completely verify the implementation of the DSL. To our knowledge, there is, to our knowledge, no verified implementation of a reversible language. Therefore, we are aiming at providing a fully verified implementation. If this full verification is not possible, the contingency plan is to at least verify the basic, non-extended version of Janus. 
\item \textbf{Impossible applications} It is a possibility that the applications that will be implemented in the DSL are impossible to implement in a reversible language. If there is an application where there is no suitable variant found that can be implemented in a reversible language, that specific application will be ignored or a suitable replacement will be looked for. 
\item \textbf{Impossible use of libraries} There is the risk that one of the proposed libraries we plan to use to implement the DSL turns out not to be suitable. This may be the case because the library lacks some features that are necessary for the implementation of the DSL. If this is the case, a replacement will be looked for. If no suitable replacement can be found, the functionality will either be implemented in another way without the use of a library or will be removed from the specification.
\end{itemize} 

\subsection{Goal}

\section{Planning}

\setlength{\tabcolsep}{20pt}
\renewcommand{\arraystretch}{1.6}
\begin{center}
\begin{tabular}{cl}
\multirow{2}{*}{\textsc{week 1}} &
	\textbf{Task 1:} Orestis,... \\ {} &
	\textbf{Task 2:} Cas,... \\ \hline
\multirow{2}{*}{\textsc{week 2}} &
	\textbf{Task 3:} Joris1, Joris2,... \\ {} &
\textbf{Task 4:} Ivo,... \\ \hline
\multirow{2}{*}{\textsc{week 3}} &
	\textbf{Task 1:} Orestis,... \\ {} &
	\textbf{Task 2:} Cas,... \\
\rowcolor{green} \multicolumn{2}{c}{\textsc{Progress Report}} \\
\multirow{2}{*}{\textsc{week 4}} &
	\textbf{Task 3:} Joris1, Joris2,... \\ {} &
	\textbf{Task 4:} Ivo,... \\ \hline
\multirow{2}{*}{\textsc{week 5}} &
	\textbf{Task 1:} Orestis,... \\ {} &
	\textbf{Task 2:} Cas,... \\ \hline
\multirow{2}{*}{\textsc{week 6}} &
	\textbf{Task 3:} Joris1, Joris2,... \\ {} &
	\textbf{Task 4:} Ivo,... \\
\rowcolor{green} \multicolumn{2}{c}{\textsc{Project Submission}}
\end{tabular}
\end{center}
\end{document}
