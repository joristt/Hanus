% !TeX spellcheck = en_US
\documentclass[12pt,a4paper]{article}

\usepackage{minted}

% Tables
\usepackage{multicol}
\usepackage{multirow}
\usepackage{csquotes}
\usepackage{fullpage}

\usepackage{amsmath,amsthm,amssymb,latexsym}

% Colors
\usepackage{xcolor, color, colortbl}
\colorlet{gray}{gray!70}
\colorlet{green}{green!50}

% Links
\usepackage{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour}

\usepackage{titlesec}

\setcounter{secnumdepth}{4}


\usepackage{minted}
%\usemintedstyle{friendly}
\usemintedstyle{tango}
%\usemintedstyle{monokai}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\title{\textbf{Project Report \\ \small{Concepts of Program Design}}}
\author{\small{Joris ten Tusscher, Joris Burgers, Ivo Gabe de Wolff, Cas van der Rest, Orestis Melkonian}}
\date{}

% Macros
\newcommand{\site}[1]{\footnote{\url{#1}}}
\newcommand{\inlinecode}[1]{\mintinline{bash}{#1}}

\newcommand{\code}[2]{
	\begin{center}
		\vspace{.5cm}
		\textsc{\small #1}\\
		\vspace{.5cm}
	\end{center}
	\begin{minipage}{.9\textwidth}
		\inputminted[frame=lines,framesep=1cm,baselinestretch=.8,linenos,fontsize=\footnotesize]
			{haskell}{code/#2.hs}
	\end{minipage}
}

\begin{document}
\maketitle


\section{Problem}
\label{section:problem}
    \subsection{Experiment}
In Janus, a time-reversible programming languages, all procedures can be executed forward and backward. This gives a limitation on the programs that a programmer can write and makes it thus hard to write certain applications. That gave us the following research question for our experiment:

\begin{displayquote}
	\textit{Can we improve the usability of Janus by implementing it as a DSL embedded in Haskell?}
\end{displayquote}

\noindent In order to be able to answer this question, we attempted to improve Janus in several ways, mainly by incorporating various elements of the host language (Haskell) in the DSL, as well as the addition of certain language constructs. We implemented certain algorithms in both our DSL and standard Janus and compared the implementations with respect to various metrics, such as performance and readability. 

In this report, we will describe our implementation of the Janus as a DSL in Haskell, which we called \textit{Hanus}. We will start by giving some context on Janus and reversible languages in general in section \ref{section:problem}. We will describe the extensions and expected outcome in section \ref{section:methodology}. We describe on the results of our DSL in section \ref{section:results} and reflect on the process in section \ref{section:reflect}.

\subsection{Janus}
We implemented the reversible programming language Janus as a DSL in Haskell. The syntax and semantics given by Lutz en Derby \cite{lutz82} were used. There will however be a few changes. There will be no input and output in the DSL. Therefore, the \texttt{READ} and \texttt{WRITE} statements will not be valid statements

\subsection{Extensions}
We added various extensions, mainly focused on improving the usability of our DSL:

\begin{itemize}
	\item 
	Local variable blocks
	\item
	Function arguments
	\item
	Arbitrary types
\end{itemize}

Some Janus features, such as the stack and arrays will not be implemented directly into the DSL, but are available through predefined functions in the host language.

\subsection{$r$-Turing completeness}
Given that only reversible programs can be written in a reversible language, it can only compute injective functions. This means that it cannot simulate any Turing machine, as Turing machines can compute non-injective functions. Thus, reversible languages are not Turing complete \cite{axelsen11}.

Axelsen e.a. \cite{axelsen11} proposed the notion of reversible Turing completeness ($r$-Turing completeness), meaning that the language can simulate any reversible Turing machine (RTM). To define this, we must first know the concepts of forward and backward determinism.

\begin{itemize}
	\item A Turing machine is \textit{forward deterministic} if from any state and tape, only one transition to a new state and tape exists.
	\item Similarly, a Turing machine is \textit{backward deterministic} if given any state and tape, only one transition that leads to this state exists.
\end{itemize}

A reversible Turing machine is defined as a forward and backward deterministic Turing machine.

\subsubsection{Convert Turing machines}
If we want to compute some non-injective function $f(x)$, we can create an injective function $x \to (f(x), x)$. As shown by \cite{axelsen11}, if $f(x)$ is computable by some Turing machine, then there exists a reversible Turing machine which computes $x \to (f(x), x)$ which uses three memory tapes instead of one. This three-tape reversible Turing machine can be converted to a normal single tape reversible Turing machine.

Given a computable function $f$, we can thus write a program in a reversible language that computes $x \to (f(x), x)$. However, this might use more memory and time than in a non-reversible language.

In Hanus, this trick can be used with only a minimal amount of additional memory and time. For simplicity, assume that $f$ is a function from integers to integers. When function $f$ is implemented in Haskell, a Hanus procedure that computes $(0, x) \to (f(x), x)$ can be created as follows.

\begin{minted}{haskell}
procedure g(y :: Int, x :: Int) {
  y += f x;
}
\end{minted}

\section{Methodology}
\label{section:methodology}
\subsection{DSL Embedding}
\label{subsec:template-haskell}
In order to embed Janus as a DSL in Haskell, we used the \textit{TemplateHaskell}(TH)\cite{sheard02} and \textit{QuasiQuotation}\cite{mainland07} GHC extensions, which extend Haskell with compile-time meta-programming capabilities. This allows us to perform static checking (i.e. syntactic and semantic checking), code generation and embedding Haskell expressions in Janus at compile-time.

On the static checking side of things, TH allowed us to perform the following at compile-time:
\begin{itemize}
	\item{Parsing}
	\item{Checking that programs are well-typed}
	\item{Verifying proper variable usage}
	\item{Embedding of Haskell expressions}
\end{itemize}

Specifically, Hanus programs can be written as \textit{quasi-quote} strings inside a Haskell source file, which will eventually transfer control to a \textit{quasi quoter}, that will parse and statically check desired properties of the given program, as well as compile the domain-specific syntax to Haskell code.

For instance, Hanus statements of the form \textbf{id} $\langle\textsc{reversibleOp}\rangle$ \textbf{expr} require that the identifier on the left-hand side does not occur in the expression on the right-hand side. This is easily achieved in TH via the process of \textit{reification}, which allows us to query compile-time information (e.g. a variable's type and identifier) while running our meta-programs.

In addition to compile-time guarantees, the embedded Hanus language will also inherit powerful features, already existent in Haskell (e.g. modularity via Haskell's modules).

	\subsection{Expected outcome}
	\subsection{Planning}
\section{Results}
\label{section:results}

\subsection{Parser}
We implemented the parser for Hanus using uu-parsinglib\footnote{\url{https://hackage.haskell.org/package/uu-parsinglib}}. This allowed us to write a parser using parser combinators and get error correction. However, the error correction was not very reliable and can cause that the program does not terminate if there is a syntactic error. We expect that this is caused by the way that we parse Haskell expressions.

\subsubsection{Parsing Haskell expressions and types}
The syntax for our DSL supports Haskell expressions and types. We use the haskell-src-meta package\footnote{\url{https://hackage.haskell.org/package/haskell-src-meta}} to parse those. However, to use this package, we must know where a Haskell expression or type ends. Consider an assignment of the form \textit{x += expr;}, where \texttt{expr} is some expression. We will find the first occurrence of a semicolon in the source string and try to parse this section of the source. If the source code is \texttt{x += length "a;b";}, it will try to parse \texttt{length "a} as a Haskell expression. This will fail, and the parser will try to find the next occurrence of a semicolon. Thus, it will try to parse \texttt{length "a;b"}, which does parse.

We expect that this does not play well with the error correction mechanisms of uu-parsinglib and cause that the parser does not terminate on invalid inputs. However, on some inputs the error correction does correct the input.



	
	\subsubsection{Semantics of operators}	
	In Hanus, a user is able to define their own types and operators. These operators can be defined for their own types or for types that are already defined in Haskell. In Hanus, there are already a number of operators and types defined that users can use. 
	\paragraph{Definition of arbitrary types}
	In a reversible language, any variable should have a default value with which a variable is initialised before the \textit{main} procedure is run. The original \textit{Janus} specification only allowed for integers. For integers the default value of 0 is chosen. In Hanus, for any number of the \textit{Haskell Num} class, the default is also 0. There are also a number of other types predefined in Hanus. Their defaults are implemented as follows:
	\begin{itemize}
		\item Bool: \textit{False}
		\item $\lbrack\alpha\rbrack$ : \textit{[]}
		\item Map $\alpha$ $\beta$: \textit{Data.Map.empty}
		\item Maybe $\alpha$: \textit{Nothing}
	\end{itemize}
	Any user that wants to define their own type, has to implement an instance of \textit{DefaultValue} type class for the type they want to use as a \textit{Hanus} variable. It is possible to implement a \textit{DefaultValue} for a type without implementing any operators for that type. A variable of this type can not be changed in this case, except if the type also implements the type class of another type. An example of this would be the class \textit{Real}. Because any \textit{Real} in Haskell has to be also a \textit{Num}, all operators defined on \textit{Num} could also be used on a \textit{Real}.
	
	\paragraph{Definition of operators}

	In \textit{Hanus}, operators can be defined to manipulate variables.  These operators always come in pairs, one operator for the forward manipulation and one operator for the reverse manipulation. There is no restriction that these operators should be different. For example, the reverse of the negation operator is the negation operator. However, in most circumstances, there operator are two different manipulations. In the original \textit{Janus}, there were 4 manipulation operators defined. There are the operators \texttt{+=}, \texttt{-=}, \texttt{\textasciicircum =} and $\Leftrightarrow$. All of these operators only work on integers, as the original \textit{Janus} does not support any other types. The semantics are as follows:
	\begin{itemize}
		\item \texttt{x+=e} adds any arbitrary expression \texttt{e} to the variable \texttt{x}. The reverse of this statement is \texttt{x-=e}. As long as the variable on the right hand side of the operator is not used in the expression $e$, $e$ can by any computation that results in an integer. The expression \texttt{x+=x} is therefore not allowed, because this statement does not have a reverse. The constraint that the variable on the left can not occur on the right applies for all operators.
		\item \texttt{x-=e} subtract the arbitrary expression \texttt{e} from the variable \texttt{x}. The reverse is the statement \texttt{x+=e}.
		\item \texttt{x \textasciicircum = e} does a bitwise $xor$ with the expression \texttt{e}. This operator is its own reverse. 
		\item \texttt{$x\Leftrightarrow y$} is the swap manipulator. This operator takes two variables and swaps their values. This operator is its own reverse. 
	\end{itemize}
	For a user to implement their own operator in \textit{Hanus}, they have to define their operator to be the of the type \textit{Operator}. The type \textit{Operator} is defined in \textit{Haskell} as $Operator$ $\alpha$ $\beta = Operator$ $ (\alpha \rightarrow  \beta \rightarrow  \alpha)$ $(\alpha \rightarrow  \beta \rightarrow \alpha)$. The first variable is the operator to be used in forward operation, the second variable is the reverse of the first operator. The definition of \texttt{+=} in \textit{Hanus} is \texttt{(+=) = Operator  (+) (-)}. A user can use the function \texttt{inverse} to inverse an \textit{Operator}. The definition of \texttt{-=} would become \texttt{(-=) = inverse (+=).} Other operators that are defined for the users convenience include \texttt{\textasciicircum =}, swap, push and pop on a stack. All these operators are defined in \textit{Haskell}. Any user wanting to implement their own operators have to define these in \textit{Haskell}, as their is no way to define these in \textit{Hanus}.

	\paragraph{Guarantee of reversibility}
	The \textit{Operator} type does not guarantee reversibility. This means that there is no check that if a user specifies two manipulations $m_1$ and $m_2$ that $(x \; m_1 \; e) \; m_2 \; e = x$ holds for every variable $x$ and every expression $e$. It is possible that the user defines \texttt{ (*=) = Operator (*) (+)}. It should be clear that this operator is incorrect, because the reverse of multiplication is not addition. However, \textit{Hanus} will not detect such a mistake and will run a program containing this code without problem. Therefore, a user that defines their own operator, should be careful to make sure that every operator they define is indeed reversible in every situation. 
	\subsubsection{Indexers}	
	Indexer are functions that are used to access specific fields in a data structure. These data structures are are implemented in \textit{Haskell} using the \textit{DefaultValue} type.
	\paragraph{Field indexer}
	A field index is an indexer used to point to a specified field of a data type. One example, implemented in \textit{Hanus}, is the type \textit{BinaryTree}. This \textit{BinaryTree} is either a \textit{Node} with a value and two sub trees or a \textit{Leaf}. The \textit{DefaultValue} of a \textit{BinaryTree} is a \textit{Leaf}. This \textit{BinaryTree} is not very useful unless there would be an option to access the values or children of the tree. This is where \textit{FieldIndexer} is used. To define a \textit{FieldIndexer}, a user should specify both a $get$ and a $set$ function. The $get$ function is used to retrieve the value from the data structure and the $set$ function is used insert the value in the data structure, possibly removing the data that was there before. This is not a problem for reversibility, because this $set$ and $get$ are never directly called by the program at runtime. They are used by the operators, retrieving the value, updating it and returning the updated value using the $set$ function. A few examples of the usage of a \textit{Field Indexer} include $x.nodeValue$ and $x.leftChild$. Each of these fields can then be used as a variable with any operator that support the type of the field.  The details of the implementation of \textit{BinaryTree} can be found in the code repository in the module $StdLib.BinaryTree$.
	\paragraph{Array indexer}	
	Array indexer have the same purpose as Field Indexer in that they are used to access specific parts of the data structure. The difference between the two indexers is that an \textit{ArrayIndexer} has one more variable. This variable is used to access a specific part of the data structure that is not necessary known at compile time. The most notable example is the default way access items in an array: $x[i]$ where $x$ is an array and $i$ is the key that points to a position in array $x$. In some languages, there is a restriction that the key has to be an integer. This restriction does not exists in \textit{Hanus}. A user is free to use any type as a key. For the definition, the \textit{ArrayIndexer} also requires two functions, one $get$ function and one $set$ function. The $get$ function requires the variable that needs to be accessed and a key that points to an item in the data structure. The $set$ function requires a function that receives the data structure, the key of the variable in the data structure and the new value that needs to be inserted in the data structure. In \textit{Hanus}, $ArrayIndexer$ is used to implement arrays. This indexer can also be used for structures like maps, lists and similar structures. 	
	
\subsection{Examples of \textit{Hanus}}	
	
\code{Division}{divide}	\\\\
The division example is a simple example of what \textit{Hanus} is capable of. This function computes the division and the remainder. When the variable is called in reverse, it can be used to compute the multiplication. Because the \textit{main} procedure calls divide and then uncalls divide with the same arguments, main acts as the identity function for most parameters. With this program, it is possible to explain the loop in \textit{Hanus}. The loop has a precondition and a postcondition and a body. The precondition has to be $True$ only the first iteration and the postcondition has to be $True$ only the last iteration. When the loop is reversed, precondition and postcondition change places. 
	
\code{Fibonacci}{fibonacci}	\\\\
The Fibonacci example has three parameters. The first two are two sequential Fibonacci numbers, the third parameters $n$ represents the $n$th parameter. This function can normally be used to calculate the $n$th Fibonacci number. The reverse of this program is, given two sequential Fibonacci numbers, what is the position of the first Fibonacci number when all Fibonacci numbers are listed. For example, $x1 = 5$ and $x2 = 8$ return $n=4$ because 5 is the fourth Fibonacci number, starting on a list with 0. This example also includes an if-statement. This if-statement differs from regular if-statements with the addition of the postcondition. This postcondition must be $True$ if the if-branch was executed and has to be $False$ if the else-branch was executed. The reverse of the if-statement is the reverse of both bodies and the reversal of the precondition and the postcondition.
\code{Run length encoding}{run-length-encoding}\\\\
The run length encoding example shows the usage of a more complicated program that uses two nested loops and a stack to store the data. The program compresses the data using run-length encoding. An example is the array $\lbrack 12, 12, 12, 13, 13 \rbrack$, which gets converted to the array $\lbrack 2, 13, 3, 12 \rbrack$. This is an example with a very useful reverse. A user has only to provide the encoder for such a compression and by uncalling the encode procedure, providing the compressed data, the original data is returned.


	\subsection{Achievements}

	\subsection{Goal/planning adjustments}
\section{Reflection}
\label{section:reflect}
	\subsection{Good/bad surprises}
	\subsection{Problems along the way}
\section{Appendix}
	\subsection{Repo link}
	\subsection{Code navigation}

\newpage
\bibliographystyle{ieeetr}
\bibliography{sources}
\end{document}
