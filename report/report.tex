% !TeX spellcheck = en_US
\documentclass[12pt,a4paper]{article}

\usepackage{minted}

% Tables
\usepackage{multicol}
\usepackage{multirow}
\usepackage{csquotes}
\usepackage{fullpage}

% Colors
\usepackage{xcolor, color, colortbl}
\colorlet{gray}{gray!70}
\colorlet{green}{green!50}

% Links
\usepackage{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour}

\title{\textbf{Project Report \\ \small{Concepts of Program Design}}}
\author{\small{Joris ten Tusscher, Joris Burgers, Ivo Gabe de Wolff, Cas van der Rest, Orestis Melkonian}}
\date{}

% Macros
\newcommand{\site}[1]{\footnote{\url{#1}}}
\newcommand{\inlinecode}[1]{\mintinline{bash}{#1}}

\begin{document}
\maketitle

\section{Problem}
    \subsection{Experiment}
    \subsection{Janus - Reversible Computation}

\subsubsection{$r$-Turing complete}
Given that only reversible programs can be written in a reversible language, it can only compute injective functions. This means that it cannot simulate any Turing machine, as Turing machines can compute non-injective functions. Thus, reversible languages are not Turing complete \cite{axelsen11}.

Axelsen e.a. \cite{axelsen11} proposed the notion of reversible Turing completeness ($r$-Turing completeness), meaning that the language can simulate any reversible Turing machine (RTM). To define this, we must first know the concepts of forward and backward determinism.

\begin{itemize}
	\item A Turing machine is \textit{forward deterministic} if from any state and tape, only one transition to a new state and tape exists.
	\item Similarly, a Turing machine is \textit{backward deterministic} if given any state and tape, only one transition that leads to this state exists.
\end{itemize}

A reversible Turing machine is defined as a forward and backward deterministic Turing machine.

\subsubsection{Convert Turing machines}
If we want to compute some non-injective function $f(x)$, we can create an injective function $x \to (f(x), x)$. As shown by \cite{axelsen11}, if $f(x)$ is computable by some Turing machine, then there exists a reversible Turing machine which computes $x \to (f(x), x)$. This machine might use more time and memory.

In Hanus, this trick can be used, with only a minimal amount of additional memory and time. For simplicity, assume that $f$ is a function from integers to integers. When function $f$ is implemented in Haskell, a Hanus procedure that computes $(0, x) \to (f(x), x)$ can be created as follows.

\begin{minted}{haskell}
procedure g(y :: Int, x :: Int) {
  y += f x;
}
\end{minted}

\section{Methodology}
	\subsection{Expected outcome}
	\subsection{Planning}
\section{Results}
	\subsection{Achievements}
	
\subsubsection{Parser}
We implemented the parser for Hanus using uu-parsinglib \footnote{\url{https://hackage.haskell.org/package/uu-parsinglib}}. This allowed us to write a parser using parser combinators and get error correction. However, the error correction was not very reliable and can cause that the program does not terminate if there is a syntactic error. We expect that this is caused by the way that we parse Haskell expressions.

\subsubsection{Parsing Haskell expressions and types}
The syntax for our DSL supports Haskell expressions and types. We use the haskell-src-meta package \footnote{\url{https://hackage.haskell.org/package/haskell-src-meta}} to parse those. However, to use this package, we must know where a Haskell expression or type ends. Consider an assignment of the form \textit{x += expr;}, where \texttt{expr} is some expression. We will find the first occurrence of a semicolon in the source string and try to parse this section of the source. If the source code is \texttt{x += length "a;b";}, it will try to parse \texttt{length "a} as a Haskell expression. This will fail, and the parser will try to find the next occurrence of a semicolon. Thus, it will try to parse \texttt{length "a;b"}, which does parse.

We expect that this does not play well with the error correction mechanisms of uu-parsinglib and cause that the parser does not terminate on invalid inputs. However, on some inputs the error correction does correct the input.
	
	\subsection{Goal/planning adjustments}
\section{Reflection}
	\subsection{Good/bad surprises}
	\subsection{Problems along the way}
\section{Appendix}
	\subsection{Repo link}
	\subsection{Code navigation}

\newpage
\bibliographystyle{ieeetr}
\bibliography{sources}
\end{document}
